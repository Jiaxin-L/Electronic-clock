C51 COMPILER V9.55   MAIN                                                                  02/27/2017 16:41:17 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REG51.H>  
   2          unsigned char code LEDDATA[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,
   3          0x82,0xf8,0x80,0x90,0xff,0x8e,0x86};
   4          //数码管显示的代码表，后三个为灭灯、"F"、"E"
   5          unsigned char code LEDBITDATA[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,}; 
   6          //数码管扫描代码表
   7          unsigned char LEDBuffer[6];     //定义显示缓冲区数组
   8          unsigned char Second;         //秒单元
   9          unsigned char Minute;         //分单元
  10          unsigned char Hour;         //时单元
  11          unsigned char Beepflag;       //定时响铃标志
  12          unsigned char Minuterom;        //定时分单元
  13          unsigned char Hourrom;        //定时时单元
  14          unsigned char SETFlag=0;        //模式标志
  15          unsigned char second_tick;        //闪动标志
  16          unsigned char Time;         //超时计数
  17          unsigned char ALMFlag=0;        //定时开启标志
  18          sbit SET_KEY=P3^3;          //模式键
  19          sbit DOWN_KEY=P3^4;       //加计数键
  20          sbit UP_KEY=P3^5;         //减计数键
  21          sbit ALM_KEY=P3^2;          //显示定时时间按键
  22          sbit Beep=P1^7;           //蜂鸣器接口引脚
  23          
  24          
  25          void init()
  26          {   TMOD=0x01;            //T0初始化方式1,定时
  27   1        TH0=(65536-2000)/256;       //TH0,TL0装入定时2mS的初值
  28   1        TL0=(65536-2000)%256;
  29   1        TR0=1;              //启动T0工作
  30   1        ET0=1;              //允许T0溢出中断
  31   1        EA=1;             //CPU开中断
  32   1      }
  33          
  34          void Delay(unsigned int t)          //延时子程序
  35          { while(t)t--;
  36   1      }
  37          void key()                //键盘操作子程序
  38          { unsigned char i;            //缓冲数组位数标志
  39   1        char Num;             //临时数字，存储数组合并值
  40   1        if(SET_KEY==0)          //判断模式键是否按下
  41   1        { Delay(500);         //去按键抖动
  42   2          if(SET_KEY==0)        //再判断是否真得按下了
  43   2          {   SETFlag++;        //状态改变
  44   3            if(SETFlag==7) SETFlag=0;   //返回正常模式
  45   3            if(SETFlag==1) i=4;     //调节读取显示数组的位数
  46   3            if(SETFlag==2) i=2;
  47   3            if(SETFlag==3) i=0;
  48   3            if(SETFlag==4) i=4;
  49   3            if(SETFlag==5) i=2;
  50   3            if(SETFlag==6) i=0;
  51   3          }
  52   2        while(SET_KEY==0);          //等按键释放
  53   2        }
  54   1      
C51 COMPILER V9.55   MAIN                                                                  02/27/2017 16:41:17 PAGE 2   

  55   1        if((UP_KEY==0)&&(SETFlag!=0))   //判断加计数键是否按下
  56   1        {
  57   2          Delay(5000);          //去按键抖动
  58   2          if(UP_KEY==0)         //再判断是否真得按下了
  59   2          { Num=(LEDBuffer[i+1]+LEDBuffer[i]*10);
  60   3            Num++;          //时单元的数值加1
  61   3            if((Num==24)&&((SETFlag==3)||(SETFlag==5))) Num=0;  //加到24归0
  62   3            if((Num==60)&&((SETFlag==1)||(SETFlag==2)||(SETFlag==4))) Num=0;      //加到60归0
  63   3            switch(SETFlag)       //把修改值写回
  64   3            { case 0: ;break;
  65   4              case 3: Hour=Num;break;
  66   4              case 2: Minute=Num;break;
  67   4              case 1: Second=Num;break;
  68   4              case 5: Hourrom=Num;break;
  69   4              case 4: Minuterom=Num;break;
  70   4              case 6: ALMFlag=!ALMFlag;break;   
  71   4            }
  72   3          }
  73   2         }
  74   1      
  75   1        if((DOWN_KEY==0)&&(SETFlag!=0)) //判断减计数键是否按下
  76   1        {
  77   2          Delay(5000);          //去按键抖动
  78   2          if(DOWN_KEY==0)       //再判断是否真得按下了
  79   2          { Num=(LEDBuffer[i+1]+LEDBuffer[i]*10);
  80   3            Num--;          //时单元的数值减1
  81   3            if((Num<0)&&((SETFlag==3)||(SETFlag==5))) Num=23; //到24归0
  82   3            if((Num<0)&&((SETFlag==1)||(SETFlag==2)||(SETFlag==4))) Num=59;     //到60归0
  83   3            switch(SETFlag)       //把修改值写回
  84   3            { case 0: ;break;
  85   4              case 3: Hour=Num;break;
  86   4              case 2: Minute=Num;break;
  87   4              case 1: Second=Num;break;
  88   4              case 5: Hourrom=Num;break;
  89   4              case 4: Minuterom=Num;break;
  90   4              case 6: ALMFlag=!ALMFlag;break;   
  91   4            }
  92   3          }
  93   2        }
  94   1        if(ALM_KEY==0)
  95   1        {   SETFlag=0;        //状态返回
  96   2            if(ALMFlag==0)LEDBuffer[0]=11;  //根据闹铃状态显示F或者E
  97   2            else LEDBuffer[0]=12;   //将时,分,秒单元内容送入暂存区
  98   2            LEDBuffer[1]=10;      //关闭该数码管显示
  99   2            LEDBuffer[5]=Minuterom%10;
 100   2            LEDBuffer[4]=Minuterom/10;
 101   2            LEDBuffer[3]=Hourrom%10;
 102   2            LEDBuffer[2]=Hourrom/10;
 103   2            if(ALMFlag==1)
 104   2            { Beep=1;
 105   3              Beepflag=0;
 106   3            }
 107   2        }
 108   1      }      
 109          
 110          
 111          void display(void)              //显示暂存区内容对应的代码显示
 112          {   unsigned char LEDScanCount,i;       //位选扫描计数器
 113   1      P0=0xff;                //适应仿真需要
 114   1      if((UP_KEY==0)||(DOWN_KEY==0)) i=0x00;  //加减键有操作放弃闪烁
 115   1        else i = 0xff*second_tick;          //设定闪烁变量
 116   1      P2= LEDBITDATA[LEDScanCount];     //送出位选数据
C51 COMPILER V9.55   MAIN                                                                  02/27/2017 16:41:17 PAGE 3   

 117   1      switch(SETFlag)
 118   1        { case 0: P0=LEDDATA[LEDBuffer[LEDScanCount]];break;  //送出段选数据 
 119   2          case 1: if(LEDScanCount>=4)             //判断出最高两位
 120   2                 P0=i|LEDDATA[LEDBuffer[LEDScanCount]]; //使小时闪烁
 121   2              else P0=LEDDATA[LEDBuffer[LEDScanCount]];break; //低位正常显示
 122   2          case 2: if((LEDScanCount==2)||(LEDScanCount==3))    //判断出中间位
 123   2                 P0=i|LEDDATA[LEDBuffer[LEDScanCount]]; //使分钟闪烁
 124   2              else P0=LEDDATA[LEDBuffer[LEDScanCount]];break; //其他位正常显示
 125   2          case 3: if(LEDScanCount<=1)
 126   2                 P0=i|LEDDATA[LEDBuffer[LEDScanCount]];
 127   2              else P0=LEDDATA[LEDBuffer[LEDScanCount]];break;
 128   2          case 4: if(LEDScanCount>=4)
 129   2                 P0=i|LEDDATA[LEDBuffer[LEDScanCount]];
 130   2              else P0=LEDDATA[LEDBuffer[LEDScanCount]];break;
 131   2          case 5: if((LEDScanCount==2)||(LEDScanCount==3))
 132   2                 P0=i|LEDDATA[LEDBuffer[LEDScanCount]];
 133   2              else P0=LEDDATA[LEDBuffer[LEDScanCount]];break;
 134   2          case 6: if(LEDScanCount<=1)
 135   2                 P0=i|LEDDATA[LEDBuffer[LEDScanCount]];
 136   2              else P0=LEDDATA[LEDBuffer[LEDScanCount]];break;
 137   2        }
 138   1      LEDScanCount++;           //扫描指针加计数
 139   1      if(LEDScanCount==6)LEDScanCount=0 ; //扫描完从头开始;
 140   1      }
 141          
 142          
 143          void timer0_isr(void) interrupt 1
 144          {   unsigned int SecondCount;
 145   1        unsigned int timercp;         //秒计数器
 146   1        TH0=(65536-2000)/256;       //TH0,TL0装入定时2mS的初值
 147   1        TL0=(65536-2000)%256;  
 148   1        display();              //调用显示函数
 149   1        timercp++;    
 150   1        if(SETFlag!=0)            //10秒不操作自动返回
 151   1          { if((SET_KEY==0)||(UP_KEY==0)||(DOWN_KEY==0)) Time=0;  //任意键有操作放弃计时
 152   2            if (Time>=10){SETFlag=0;Time=0;}
 153   2          }
 154   1        if (timercp == 250)       
 155   1          { timercp= 0; 
 156   2            second_tick = !second_tick;     //设定0.5秒闪动一次 
 157   2            SecondCount++;
 158   2            if(SecondCount==2)        //1秒的时间
 159   2            { SecondCount=0;        //计数器清零
 160   3              Time++;         
 161   3              Second++;         //时间的秒加1
 162   3              if(Second==60)
 163   3              { Second=0;       //秒清零
 164   4                Minute++;       //分进一
 165   4                if(Minute==60)
 166   4                { Minute=0;
 167   5                  Hour++;
 168   5                  if(Hour==24)Hour=0; //小时清零
 169   5                }
 170   4              }
 171   3            }
 172   2        if(SETFlag<=3)          //状态模式小于3是加载时钟时间
 173   2            {   LEDBuffer[5]=Second%10; 
 174   3              LEDBuffer[4]=Second/10;
 175   3              LEDBuffer[3]=Minute%10;
 176   3              LEDBuffer[2]=Minute/10;
 177   3              LEDBuffer[1]=Hour%10;
 178   3              LEDBuffer[0]=Hour/10;
C51 COMPILER V9.55   MAIN                                                                  02/27/2017 16:41:17 PAGE 4   

 179   3            }
 180   2            else               //调整闹钟时间时加载闹钟时间
 181   2            { if(ALMFlag==0)LEDBuffer[0]=11; //显示闹钟激活状态
 182   3              else LEDBuffer[0]=12;
 183   3              LEDBuffer[1]=10;       //关闭倒数第二位
 184   3              LEDBuffer[5]=Minuterom%10;
 185   3              LEDBuffer[4]=Minuterom/10;
 186   3              LEDBuffer[3]=Hourrom%10;
 187   3              LEDBuffer[2]=Hourrom/10;
 188   3            }
 189   2      }
 190   1      }
 191          
 192          
 193          
 194          void main(void)
 195          { init();                 //初始化
 196   1      while(1)
 197   1      { key();              //调用键盘
 198   2          if(ALMFlag==1)
 199   2          { if(Minute!=Minuterom) Beepflag=1; //定时和现在不同，关闭蜂鸣器
 200   3            if((Hour==Hourrom)&&(Minute==Minuterom)&&(Beepflag==1)) Beep=0;
 201   3                //时分相同并闹铃打开就响铃
 202   3          }
 203   2      } 
 204   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    917    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
